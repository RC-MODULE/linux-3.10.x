/*
 *
 */

/dts-v1/;
/ {
    model = "RC-Module 1879VM8YA SoC";
    compatible = "rcm,1879VM8YA";

	#address-cells = <1>;
	#size-cells = <1>;

    aliases {
        uart0 = &spiuart;
        mmc0 = &mmc;
    }; 

    chosen {
/*
        bootargs = "earlyprintk debug";
*/
        stdout-path = &spiuart;
    };

    memory@61000000 {
        device_type = "memory";
        /* (1GiB-16MiB) memory @ 0x01000000 */
        reg = <0x61000000 0x1f000000>;
    };

    memory@81000000 {
        device_type = "memory";
        reg = <0x81000000 0x1f000000>;
    };

    memory@A1000000 {
        device_type = "memory";
        reg = <0xA1000000 0x1f000000>;
    };

    memory@C1000000 {
        device_type = "memory";
        reg = <0xC1000000 0x1f000000>;
    };

    memory@E1000000 {
        device_type = "memory";
        reg = <0xE1000000 0x1f000000>;
    };

    cpus {
        #address-cells = <1>;
        #size-cells = <0>;

        cpu0: cpu@0 {
            device_type = "cpu";
            compatible = "arm,cortex-a5";
            reg = <0x0>;
        };
    };

    axi {
        compatible = "arm,amba-bus";
        #address-cells = <1>;
        #size-cells = <1>;
        ranges = <0 0x0 0xFFFFFFFF>;

        bus-frequency = <10000000>;

        gic0: interrupt-controller@600b0000 {
            compatible = "arm,pl390";
            interrupt-controller;
            irq_start = <0>;
            #interrupt-cells = <3>;
            #address-cells = <1>;
            reg = <0x600b0000 0x1000>,
                  <0x600b1000 0x1000>;
        };

        L2: cache-controller {
            compatible = "arm,pl310-cache";
            reg = <0x000d2000 0x1000>;
            cache-unified;
            cache-level = <2>;
            cache-size = <0x80000>;
        };

        apb {
            compatible = "arm,amba-bus", "simple-bus";
            #address-cells = <1>;
            #size-cells = <1>;
            ranges = <0 0x0 0xffffffff>;

            timer@600cd000 {
                compatible = "arm,sp804", "arm,primecell";
                reg = <0x600cd000 0x1000>;
                interrupts = <0 4 4>, <0 5 4>;
                interrupt-parent = <&gic0>;
                interrupt-names = "timer0", "timer1";
                clocks = <&clk_apb>;
                clock-names = "apb_pclk";
            };

            wd@000ce000 {
                reg = <0x600ce000 0x1000>;
                compatible = "arm,sp805", "arm,primecell";
/*
                interrupts = <0 6 4>;
*/
                clocks = <&clk_apb>, <&clk_apb>;
                clock-names = "wdogclk", "apb_pclk";
            };

            spi@000cf000 {
                compatible = "arm,pl022", "arm,primecell";
                bus-id = <0>;
                reg = <0x600cf000 0x1000>;
                #address-cells = <1>;
                #size-cells = <0>;
                interrupt-parent = <&gic0>;
                interrupts = <0 34 4>;
                clocks = <&clk_apb>;
                clock-names = "apb_pclk";
                num-cs = <3>;
                
                flash-slot@0 {
                    compatible = "st,m25p80";
                    reg = <0>;
                    spi-max-frequency = <9000000>; /* DDDDDD <25000000>; */
                };
                mmc: mmc-slot@1 {
                    compatible = "mmc-spi-slot";
                    reg = <1>;
                    spi-max-frequency = <25000000>; /* DDDDDD <25000000>; */
                };
                spiuart: uart-slot@2
                {
                    compatible = "rcm,serial_pseudo_spi";
                    reg = <2>;
                    spi-max-frequency = <35000>; /* in case of (freq >= 37300) - stm32 receives data with corruption*/
                    spi-cpol;
                    spi-cpha;
                };
            };

            clk_axi: clk@0 {
                /* Reference 800MHz clock */
                compatible = "fixed-clock";
                #clock-cells = <0>;
                clock-frequency = <800000000>;
                clock-output-names = "clk_axi";
            };

            clk_apb: clk@1 {
                /* Reference 200MHz clock */
                compatible = "fixed-clock";
                #clock-cells = <0>;
                clock-frequency = <200000000>;
                clock-output-names = "clk_apb";
            };

            ethernet: greth@000d0000 {
                local-mac-address = [ ec 17 66 64 08 10 ];
                status = "okay";

                #address-cells = <1>;
                #size-cells = <1>;
                compatible = "rcm,greth";
                reg = <0x600d0000 0x1000>;
                cell-index = <0>;
                device_type = "network";
                clocks = <&clk_axi>;
                clock-names = "clk_axi";
                interrupt-parent = <&gic0>;
                interrupts = <0 35 1>;

                mdio {
                    compatible = "greth-mdio";
                    #address-cells = <1>;
                    #size-cells = <0>;

                    phy0: ethernet-phy@0 {
                        reg = <0>;  /* 0x1f */
                    };
                };
            };

            pcie_dma: pcie_dma@0x600de000 {
                compatible = "rcm,cdns-dma";
                reg = <0x600de000 0x1000>;
                #dma-cells = <1>;
                interrupt-parent = <&gic0>;
                interrupts = <0 40 4>;

                desc_area = <&ccpu_ccmb0>;
            };

            pcie_epc@600d8000 {
                compatible = "rcm,cdns-pcie-ep";
                reg = <0x600d8000 0x6000>,
                      <0x40000000 0x20000000>;
                reg-names = "reg", "mem";
                cdns,max-outbound-regions = <16>;
/*
                max-functions = /bits/ 8 <8>;
                phys = <&ep_phy0 &ep_phy1>;
                phy-names = "pcie-lane0","pcie-lane1";
*/
                csc = <&ccpu_clsc>;
            };

            pcie@600d8000 {
                compatible = "rcm,cdns-pcie-host";
                device_type = "pci";
                #address-cells = <3>;
                #size-cells = <2>;
                cdns,max-outbound-regions = <16>;
                vendor-id = /bits/ 16 <0x17cd>;
                device-id = /bits/ 16 <0x0200>;

                reg = <0x600d8000 0x6000>,
                      <0x50000000 0x00001000>,
                      <0x40000000 0x20000000>;
                reg-names = "reg", "cfg", "mem";

                ranges = <0x02000000 0x0 0x00000000  0x40000000  0x0 0x10000000>;

                #interrupt-cells = <0x1>;

                interrupt-map = <0x0 0x0 0x0  0x1  &gic0  0x0 0x0 42 0x4
                                 0x0 0x0 0x0  0x2  &gic0  0x0 0x0 43 0x4
                                 0x0 0x0 0x0  0x3  &gic0  0x0 0x0 44 0x4
                                 0x0 0x0 0x0  0x4  &gic0  0x0 0x0 45 0x4>;

                interrupt-map-mask = <0x0 0x0 0x0  0x7>;
/*
                msi-parent = <&its_pci>;

                phys = <&pcie_phy0>;
                phy-names = "pcie-phy";
*/
                status = "disabled";
            };


            thermal: thermal@0x600D1000 {
                compatible = "rcm,thermal-v2";
                reg = <0x600D1000 0x1000>;
                interrupt-parent = <&gic0>;
                interrupts = <0 3 4>;
                #thermal-sensor-cells = <0>;
            };

            ccpu_ccmb0: ccmb@0x60000000 {
                compatible = "syscon";
                reg = <0x60000000 0x20000>;
            };

            ccpu_ccmb1: ccmb@0x60020000 {
                compatible = "syscon";
                reg = <0x60020000 0x20000>;
            };

            ccpu_ccmb2: ccmb@0x60040000 {
                compatible = "syscon";
                reg = <0x60040000 0x20000>;
            };

            ccpu_ccmb3: ccmb@0x60080000 {
                compatible = "syscon";
                reg = <0x60080000 0x20000>;
            };

            pc0_cmb0 {
                compatible = "syscon";
                reg = <0x80000000 0x10000>;
            };

            pc1_cmb0 {
                compatible = "syscon";
                reg = <0xa0000000 0x10000>;
            };

            pc2_cmb0 {
                compatible = "syscon";
                reg = <0xc0000000 0x10000>;
            };

            pc3_cmb0 {
                compatible = "syscon";
                reg = <0xe0000000 0x10000>;
            };

            ccpu_crg0: crg@0x600c6000
            {
                compatible = "syscon";
                reg = <0x600c6000 0x1000>;
            };

            ccpu_crg1: crg@0x600c7000
            {
                compatible = "syscon";
                reg = <0x600c7000 0x1000>;
            };

            ccpu_crg2: crg@0x600c8000
            {
                compatible = "syscon";
                reg = <0x600c8000 0x1000>;
            };

            ccpu_crg3: crg@0x600c9000
            {
                compatible = "syscon";
                reg = <0x600c9000 0x1000>;
            };

            ccpu_clsc: csc@0x600cb000
            {
                compatible = "syscon";
                reg = <0x600cb000 0x1000>;
            };

            pc0_crgnm: crgnm@0x800ca000
            {
                compatible = "syscon";
                reg = <0x800ca000 0x1000>;
            };

            pc1_crgnm: crgnm@0xa00ca000
            {
                compatible = "syscon";
                reg = <0xa00ca000 0x1000>;
            };

            pc2_crgnm: crgnm@0xc00ca000
            {
                compatible = "syscon";
                reg = <0xc00ca000 0x1000>;
            };

            pc3_crgnm: crgnm@0xe00ca000
            {
                compatible = "syscon";
                reg = <0xe00ca000 0x1000>;
            };

            pc0_clsc: clsc@0x800cb000
            {
                compatible = "syscon";
                reg = <0x800cb000 0x1000>;
            };

            pc1_clsc: clsc@0xa00cb000
            {
                compatible = "syscon";
                reg = <0xa00cb000 0x1000>;
            };

            pc2_clsc: clsc@0xc00cb000
            {
                compatible = "syscon";
                reg = <0xc00cb000 0x1000>;
            };

            pc3_clsc: clsc@0xe00cb000
            {
                compatible = "syscon";
                reg = <0xe00cb000 0x1000>;
            };
        };
        
        arm_core0: arm_core@0x80000000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-arm";
            core-type = "arm";
            device-id = <0>;

            reg = <0x80000000 0x00080000>;  // imem
            reg-names = "imem";

            control = <&ccpu_clsc>;
            reset = <&ccpu_crg0>;

            reset_bit =     <0>;            // reset bit no
            nmi_set_reg =   <0x14>, <0>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <4>;    // sctl offset, bit-no
            hp_status_reg = <0x10>, <0>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <4>;    // sctl offset, bit-no
            hp_set_reg =    <0x14>, <0>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <4>;    // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <0>;    // sctl offset, bit-no

            irq_polling;

            interrupt-parent = <&gic0>;
            interrupts = <0 48 4>, <0 8 4>;
            interrupt-names = "lp", "hp";
            status = "okay";
        };

        arm_core1: arm_core@0xa0000000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-arm";
            core-type = "arm";
            device-id = <1>;

            reg = <0xa0000000 0x00080000>;  // imem
            reg-names = "imem";

            control = <&ccpu_clsc>;
            reset = <&ccpu_crg1>;

            reset_bit =     <0>;            // reset bit no
            nmi_set_reg =   <0x14>, <1>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <5>;    // sctl offset, bit-no
            hp_status_reg = <0x10>, <1>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <5>;    // sctl offset, bit-no
            hp_set_reg =    <0x14>, <1>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <5>;    // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <1>;    // sctl offset, bit-no

            irq_polling;

            interrupt-parent = <&gic0>;
            interrupts = <0 49 4>, <0 9 4>;
            interrupt-names = "lp", "hp";
            status = "okay";
        };

        arm_core2: arm_core@0xc0000000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-arm";
            core-type = "arm";
            device-id = <2>;

            reg = <0xc0000000 0x00080000>;  // imem
            reg-names = "imem";

            control = <&ccpu_clsc>;
            reset = <&ccpu_crg2>;

            reset_bit =     <0>;            // reset bit no
            nmi_set_reg =   <0x14>, <2>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <6>;    // sctl offset, bit-no
            hp_status_reg = <0x10>, <2>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <6>;    // sctl offset, bit-no
            hp_set_reg =    <0x14>, <2>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <6>;    // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <2>;    // sctl offset, bit-no

            irq_polling;

            interrupt-parent = <&gic0>;
            interrupts = <0 50 4>, <0 10 4>;
            interrupt-names = "lp", "hp";
            status = "okay";
        };

        arm_core3: arm_core@0xe0000000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-arm";
            core-type = "arm";
            device-id = <3>;

            reg = <0xe0000000 0x00080000>;  // imem
            reg-names = "imem";

            control = <&ccpu_clsc>;
            reset = <&ccpu_crg3>;

            reset_bit =     <0>;            // reset bit no
            nmi_set_reg =   <0x14>, <3>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <7>;    // sctl offset, bit-no
            hp_status_reg = <0x10>, <3>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <7>;    // sctl offset, bit-no
            hp_set_reg =    <0x14>, <3>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <7>;    // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <3>;    // sctl offset, bit-no

            irq_polling;

            interrupt-parent = <&gic0>;
            interrupts = <0 51 4>, <0 11 4>;
            interrupt-names = "lp", "hp";
            status = "okay";
        };

        nmc_0_core0: nmc_core@0x80100000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-nmc";
            core-type = "nmc4";
            device-id = <4>;

            reg = <0x80100000 0x00040000>;  // imem
            reg-names = "imem";

            control = <&pc0_clsc>;
            reset = <&pc0_crgnm>;

            reset_bit =     <0>;            // reset bit no
            nmi_set_reg =   <0x0C>, <0>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <12>;   // sctl offset, bit-no
            hp_status_reg = <0x10>, <4>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <12>;   // sctl offset, bit-no
            hp_set_reg =    <0x14>, <4>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <12>;   // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <4>;    // sctl offset, bit-no

            irq_polling;

            status = "okay";
        };

        nmc_0_core1: nmc_core@0x80180000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-nmc";
            core-type = "nmc4";
            device-id = <5>;

            reg = <0x80180000 0x00040000>;  // imem
            reg-names = "imem";

            control = <&pc0_clsc>;
            reset = <&pc0_crgnm>;

            reset_bit =     <1>;            // reset bit no
            nmi_set_reg =   <0x0C>, <1>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <13>;   // sctl offset, bit-no
            hp_status_reg = <0x10>, <5>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <13>;   // sctl offset, bit-no
            hp_set_reg =    <0x14>, <5>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <13>;   // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <5>;    // sctl offset, bit-no

            irq_polling;

            status = "okay";
        };

        nmc_0_core2: nmc_core@0x80200000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-nmc";
            core-type = "nmc4";
            device-id = <6>;

            reg = <0x80200000 0x00040000>;  // imem
            reg-names = "imem";

            control = <&pc0_clsc>;
            reset = <&pc0_crgnm>;

            reset_bit =     <2>;            // reset bit no
            nmi_set_reg =   <0x0C>, <2>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <14>;   // sctl offset, bit-no
            hp_status_reg = <0x10>, <6>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <14>;   // sctl offset, bit-no
            hp_set_reg =    <0x14>, <6>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <14>;   // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <6>;    // sctl offset, bit-no

            irq_polling;

            status = "okay";
        };

        nmc_0_core3: nmc_core@0x80280000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-nmc";
            core-type = "nmc4";
            device-id = <7>;

            reg = <0x80280000 0x00040000>;  // imem
            reg-names = "imem";

            control = <&pc0_clsc>;
            reset = <&pc0_crgnm>;

            reset_bit =     <3>;            // reset bit no
            nmi_set_reg =   <0x0C>, <3>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <15>;   // sctl offset, bit-no
            hp_status_reg = <0x10>, <7>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <15>;   // sctl offset, bit-no
            hp_set_reg =    <0x14>, <7>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <15>;   // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <7>;    // sctl offset, bit-no

            irq_polling;

            status = "okay";
        };

        nmc_1_core0: nmc_core@0xa0100000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-nmc";
            core-type = "nmc4";
            device-id = <8>;

            reg = <0xa0100000 0x00040000>;  // imem
            reg-names = "imem";

            control = <&pc1_clsc>;
            reset = <&pc1_crgnm>;

            reset_bit =     <0>;            // reset bit no
            nmi_set_reg =   <0x0C>, <0>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <12>;   // sctl offset, bit-no
            hp_status_reg = <0x10>, <4>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <12>;   // sctl offset, bit-no
            hp_set_reg =    <0x14>, <4>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <12>;   // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <4>;    // sctl offset, bit-no

            irq_polling;

            status = "okay";
        };

        nmc_1_core1: nmc_core@0xa0180000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-nmc";
            core-type = "nmc4";
            device-id = <9>;

            reg = <0xa0180000 0x00040000>;  // imem
            reg-names = "imem";

            control = <&pc1_clsc>;
            reset = <&pc1_crgnm>;

            reset_bit =     <1>;            // reset bit no
            nmi_set_reg =   <0x0C>, <1>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <13>;   // sctl offset, bit-no
            hp_status_reg = <0x10>, <5>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <13>;   // sctl offset, bit-no
            hp_set_reg =    <0x14>, <5>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <13>;   // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <5>;    // sctl offset, bit-no

            irq_polling;

            status = "okay";
        };

        nmc_1_core2: nmc_core@0xa0200000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-nmc";
            core-type = "nmc4";
            device-id = <10>;

            reg = <0xa0200000 0x00040000>;  // imem
            reg-names = "imem";

            control = <&pc1_clsc>;
            reset = <&pc1_crgnm>;

            reset_bit =     <2>;            // reset bit no
            nmi_set_reg =   <0x0C>, <2>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <14>;   // sctl offset, bit-no
            hp_status_reg = <0x10>, <6>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <14>;   // sctl offset, bit-no
            hp_set_reg =    <0x14>, <6>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <14>;   // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <6>;    // sctl offset, bit-no

            irq_polling;

            status = "okay";
        };

        nmc_1_core3: nmc_core@0xa0280000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-nmc";
            core-type = "nmc4";
            device-id = <11>;

            reg = <0xa0280000 0x00040000>;  // imem
            reg-names = "imem";

            control = <&pc1_clsc>;
            reset = <&pc1_crgnm>;

            reset_bit =     <3>;            // reset bit no
            nmi_set_reg =   <0x0C>, <3>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <15>;   // sctl offset, bit-no
            hp_status_reg = <0x10>, <7>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <15>;   // sctl offset, bit-no
            hp_set_reg =    <0x14>, <7>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <15>;   // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <7>;    // sctl offset, bit-no

            irq_polling;

            status = "okay";
        };

        nmc_2_core0: nmc_core@0xc0100000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-nmc";
            core-type = "nmc4";
            device-id = <12>;

            reg = <0xc0100000 0x00040000>;  // imem
            reg-names = "imem";

            control = <&pc2_clsc>;
            reset = <&pc2_crgnm>;

            reset_bit =     <0>;            // reset bit no
            nmi_set_reg =   <0x0C>, <0>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <12>;   // sctl offset, bit-no
            hp_status_reg = <0x10>, <4>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <12>;   // sctl offset, bit-no
            hp_set_reg =    <0x14>, <4>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <12>;   // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <4>;    // sctl offset, bit-no

            irq_polling;

            status = "okay";
        };

        nmc_2_core1: nmc_core@0xc0180000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-nmc";
            core-type = "nmc4";
            device-id = <13>;

            reg = <0xc0180000 0x00040000>;  // imem
            reg-names = "imem";

            control = <&pc2_clsc>;
            reset = <&pc2_crgnm>;

            reset_bit =     <1>;            // reset bit no
            nmi_set_reg =   <0x0C>, <1>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <13>;   // sctl offset, bit-no
            hp_status_reg = <0x10>, <5>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <13>;   // sctl offset, bit-no
            hp_set_reg =    <0x14>, <5>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <13>;   // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <5>;    // sctl offset, bit-no

            irq_polling;

            status = "okay";
        };

        nmc_2_core2: nmc_core@0xc0200000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-nmc";
            core-type = "nmc4";
            device-id = <14>;

            reg = <0xc0200000 0x00040000>;  // imem
            reg-names = "imem";

            control = <&pc2_clsc>;
            reset = <&pc2_crgnm>;

            reset_bit =     <2>;            // reset bit no
            nmi_set_reg =   <0x0C>, <2>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <14>;   // sctl offset, bit-no
            hp_status_reg = <0x10>, <6>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <14>;   // sctl offset, bit-no
            hp_set_reg =    <0x14>, <6>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <14>;   // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <6>;    // sctl offset, bit-no

            irq_polling;

            status = "okay";
        };

        nmc_2_core3: nmc_core@0xc0280000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-nmc";
            core-type = "nmc4";
            device-id = <15>;

            reg = <0xc0280000 0x00040000>;  // imem
            reg-names = "imem";

            control = <&pc2_clsc>;
            reset = <&pc2_crgnm>;

            reset_bit =     <3>;            // reset bit no
            nmi_set_reg =   <0x0C>, <3>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <15>;   // sctl offset, bit-no
            hp_status_reg = <0x10>, <7>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <15>;   // sctl offset, bit-no
            hp_set_reg =    <0x14>, <7>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <15>;   // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <7>;    // sctl offset, bit-no

            irq_polling;

            status = "okay";
        };

        nmc_3_core0: nmc_core@0xe0100000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-nmc";
            core-type = "nmc4";
            device-id = <16>;

            reg = <0xe0100000 0x00040000>;  // imem
            reg-names = "imem";

            control = <&pc3_clsc>;
            reset = <&pc3_crgnm>;

            reset_bit =     <0>;            // reset bit no
            nmi_set_reg =   <0x0C>, <0>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <12>;   // sctl offset, bit-no
            hp_status_reg = <0x10>, <4>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <12>;   // sctl offset, bit-no
            hp_set_reg =    <0x14>, <4>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <12>;   // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <4>;    // sctl offset, bit-no

            irq_polling;

            status = "okay";
        };

        nmc_3_core1: nmc_core@0xe0180000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-nmc";
            core-type = "nmc4";
            device-id = <17>;

            reg = <0xe0180000 0x00040000>;  // imem
            reg-names = "imem";

            control = <&pc3_clsc>;
            reset = <&pc3_crgnm>;

            reset_bit =     <1>;            // reset bit no
            nmi_set_reg =   <0x0C>, <1>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <13>;   // sctl offset, bit-no
            hp_status_reg = <0x10>, <5>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <13>;   // sctl offset, bit-no
            hp_set_reg =    <0x14>, <5>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <13>;   // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <5>;    // sctl offset, bit-no

            irq_polling;

            status = "okay";
        };

        nmc_3_core2: nmc_core@0xe0200000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-nmc";
            core-type = "nmc4";
            device-id = <18>;

            reg = <0xe0200000 0x00040000>;  // imem
            reg-names = "imem";

            control = <&pc3_clsc>;
            reset = <&pc3_crgnm>;

            reset_bit =     <2>;            // reset bit no
            nmi_set_reg =   <0x0C>, <2>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <14>;   // sctl offset, bit-no
            hp_status_reg = <0x10>, <6>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <14>;   // sctl offset, bit-no
            hp_set_reg =    <0x14>, <6>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <14>;   // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <6>;    // sctl offset, bit-no

            irq_polling;

            status = "okay";
        };

        nmc_3_core3: nmc_core@0xe0280000 {
            compatible = "rcm,easynmc";
            core-name = "1879VM8YA-nmc";
            core-type = "nmc4";
            device-id = <19>;

            reg = <0xe0280000 0x00040000>;  // imem
            reg-names = "imem";

            control = <&pc3_clsc>;
            reset = <&pc3_crgnm>;

            reset_bit =     <3>;            // reset bit no
            nmi_set_reg =   <0x0C>, <3>;    // sctl offset, bit-no
            lp_status_reg = <0x10>, <15>;   // sctl offset, bit-no
            hp_status_reg = <0x10>, <7>;    // sctl offset, bit-no
            lp_set_reg =    <0x14>, <15>;   // sctl offset, bit-no
            hp_set_reg =    <0x14>, <7>;    // sctl offset, bit-no
            lp_clr_reg =    <0x10>, <15>;   // sctl offset, bit-no
            hp_clr_reg =    <0x10>, <7>;    // sctl offset, bit-no

            irq_polling;

            status = "okay";
        };
    };

    thermal-zones {
        cpu-thermal {
            polling-delay-passive = <0>;
            polling-delay =  <1000>;
            thermal-sensors = <&thermal>;

            trips {
                cpu-crit {
                    temperature = <100000>;
                    hysteresis = <0>;
                    type = "critical";
                };
            };

            cooling-maps {
            };
        };
    };
};

